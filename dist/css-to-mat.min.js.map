{"version":3,"file":"css-to-mat.min.js","sources":["../src/CssToMatrix.ts"],"sourcesContent":["import { splitComma, splitBracket, splitUnit, splitSpace, isArray } from \"@daybrush/utils\";\nimport { MatrixInfo } from \"./types\";\nimport { calculate, invert, matrix3d, rotateX3d, rotateY3d, rotateZ3d, scale3d, translate3d } from \"@scena/matrix\";\n\nexport function createMatrix() {\n    return [\n        1, 0, 0, 0,\n        0, 1, 0, 0,\n        0, 0, 1, 0,\n        0, 0, 0, 1,\n    ];\n}\nexport function parseMat(transform: string | string[]): number[] {\n    return toMat(parse(transform));\n}\nexport function getElementMatrix(el: HTMLElement) {\n    return parseMat(getComputedStyle(el).transform!);\n}\nexport function calculateMatrixDist(matrix: number[], pos: number[]) {\n    const res = calculate(matrix, [pos[0], pos[1] || 0, pos[2] || 0, 1], 4);\n    const w = res[3] || 1;\n\n    return [\n        res[0] / w,\n        res[1] / w,\n        res[2] / w,\n    ];\n}\nexport function getDistElementMatrix(el: HTMLElement, container = document.body): number[] {\n    let target: HTMLElement | null = el;\n    let matrix = createMatrix();\n\n    while (target) {\n        const transform = getComputedStyle(target).transform!;\n        matrix = matrix3d(parseMat(transform), matrix);\n\n        if (target === container) {\n            break;\n        }\n        target = target.parentElement;\n    }\n    matrix = invert(matrix, 4);\n\n    matrix[12] = 0;\n    matrix[13] = 0;\n    matrix[14] = 0;\n\n    return matrix;\n}\n\nexport function toMat(matrixInfos: MatrixInfo[]): number[] {\n    let target = createMatrix();\n\n    matrixInfos.forEach(info => {\n        const {\n            matrixFunction,\n            functionValue,\n        } = info;\n\n        if (!matrixFunction) {\n            return;\n        }\n        target = matrixFunction(target, functionValue);\n    });\n    return target;\n}\nexport function parse(transform: string | string[]): MatrixInfo[] {\n    const transforms = isArray(transform) ? transform : splitSpace(transform);\n\n    return transforms.map(t => {\n        const { prefix: name, value } = splitBracket(t);\n\n\n        let matrixFunction = null;\n        let functionName: string = name;\n        let functionValue: any = \"\";\n\n        if (name === \"translate\" || name === \"translateX\" || name === \"translate3d\") {\n            const [posX, posY = 0, posZ = 0] = splitComma(value!).map(v => parseFloat(v));\n\n            matrixFunction = translate3d;\n            functionValue = [posX, posY, posZ];\n        } else if (name === \"translateY\") {\n            const posY = parseFloat(value!);\n\n            matrixFunction = translate3d;\n            functionValue = [0, posY, 0];\n        } else if (name === \"translateZ\") {\n            const posZ = parseFloat(value!);\n\n            matrixFunction = translate3d;\n            functionValue = [0, 0, posZ];\n        } else if (name === \"scale\" || name === \"scale3d\") {\n            const [sx, sy = sx, sz = 1] = splitComma(value!).map(v => parseFloat(v)) as number[];\n\n            matrixFunction = scale3d;\n            functionValue = [sx, sy, sz];\n        } else if (name === \"scaleX\") {\n            const sx = parseFloat(value!);\n\n            matrixFunction = scale3d;\n            functionValue = [sx, 1, 1];\n        } else if (name === \"scaleY\") {\n            const sy = parseFloat(value!);\n\n            matrixFunction = scale3d;\n            functionValue = [1, sy, 1];\n        } else if (name === \"scaleZ\") {\n            const sz = parseFloat(value!);\n\n            matrixFunction = scale3d;\n            functionValue = [1, 1, sz];\n        } else if (name === \"rotate\" || name === \"rotateZ\" || name === \"rotateX\" || name === \"rotateY\") {\n            const { unit, value: unitValue } = splitUnit(value!);\n            const rad = unit === \"rad\" ? unitValue : unitValue * Math.PI / 180;\n\n            if (name === \"rotate\" || name === \"rotateZ\") {\n                functionName = \"rotateZ\";\n                matrixFunction = rotateZ3d;\n            } else if (name === \"rotateX\") {\n                matrixFunction = rotateX3d;\n            } else if (name === \"rotateY\") {\n                matrixFunction = rotateY3d;\n            }\n            functionValue = rad;\n        } else if (name === \"matrix3d\") {\n            matrixFunction = matrix3d;\n            functionValue = splitComma(value!).map(v => parseFloat(v));\n        } else if (name === \"matrix\") {\n            const m = splitComma(value!).map(v => parseFloat(v));\n            matrixFunction = matrix3d;\n            functionValue = [\n                m[0], m[1], 0, 0,\n                m[2], m[3], 0, 0,\n                0, 0, 1, 0,\n                m[4], m[5], 0, 1,\n            ];\n        } else {\n            functionName = \"\";\n        }\n        return {\n            name: name!,\n            functionName,\n            value: value!,\n            matrixFunction,\n            functionValue,\n        };\n    });\n}\n"],"names":["createMatrix","parseMat","transform","toMat","parse","matrixInfos","target","forEach","info","matrixFunction","functionValue","isArray","splitSpace","map","t","_a","name","value","functionName","_b","posX","_c","posY","_d","translate3d","parseFloat","_e","sx","_f","sy","_g","scale3d","_h","unit","unitValue","rotateZ3d","rotateX3d","rotateY3d","Math","PI","matrix3d","splitComma","v","m","el","container","document","body","matrix","getComputedStyle","parentElement","invert","pos","res","calculate","w"],"mappings":"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"}